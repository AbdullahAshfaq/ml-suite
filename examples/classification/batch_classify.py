##################################################################################
# Copyright (c) 2017, Xilinx, Inc.
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##################################################################################


#!/usr/bin/python

import argparse
import collections
import os.path
import math
import sys
import timeit
import xdnn, xdnn_io
import numpy as np
from multiprocessing import Process, Queue
from ctypes import *

import datetime

g_doQuant = False
g_fpgaCfgFile = ""
g_scaleA = 10000
g_scaleB = 30
g_mean = [104.007, 116.669, 122.679] # BGR for Caffe
g_img_shape = [3, 224, 224]

g_xdnnTestDataDir = "data/googlenet_v1"
g_fpgaOutputSize = 1024
g_outputSize = 1000
g_firstFpgaLayerName = "conv1/7x7_s2"
g_labelFile = "synset_words.txt"
g_goldenFile = None
g_xclbin = "kernel.xclbin"
g_netFile = "googlenet.fpgaaddr.64.txt"
g_xdnnLib = "libxblas.so"
g_inputImageDir = None
g_allInputImageFiles = None
g_allInputImageFilesReadIdx = 0
g_batchSize = 4
g_numDevices = 1
g_inputs = None
g_inputbuf = None
g_imgbuf = None
g_useBlas = False
g_zmqPub = False
g_perpetual = False

def processCommandLine():
  global g_xclbin
  global g_netFile
  global g_fpgaCfgFile
  global g_xdnnTestDataDir
  global g_labelFile
  global g_goldenFile
  global g_inputImageDir
  global g_xdnnLib
  global g_doQuant
  global g_fpgaOutputSize
  global g_outputSize
  global g_firstFpgaLayerName
  global g_useBlas
  global g_zmqPub
  global g_perpetual

  parser = argparse.ArgumentParser(description='pyXDNN')
  parser.add_argument('--xclbin',
    help='.xclbin file')
  parser.add_argument('--netcfg',
    help='FPGA instructions generated by compiler for the network')
  parser.add_argument('--quantizecfg',
    help='FPGA config file')
  parser.add_argument('--xlnxlib',
    help='FPGA xfDNN lib .so')
  parser.add_argument('--fpgaoutsz',
    help='size of 1 FPGA output blob')
  parser.add_argument('--outsz',
    help='size of 1 output blob')
  parser.add_argument('--firstfpgalayer',
    help='name of first FPGA layer (to start quantization)')
  parser.add_argument('--datadir',
    help='path to data files to run for the network')
  parser.add_argument('--labels',
    help='result -> labels translation file')
  parser.add_argument('--golden',
    help='file idx -> expected label file')
  parser.add_argument('--imagedir',
    help='directory with image files to classify')
  parser.add_argument('--useblas', action='store_true',
    help='use BLAS-optimized functions (requires xfDNN lib compiled with BLAS)')
  parser.add_argument('--zmqpub', 
    help='publish predictions to zmq port 5555')
  parser.add_argument('--perpetual', 
    help='loop over input images forever')
  args = parser.parse_args()

  if os.path.isfile(args.xclbin) and os.access(args.xclbin, os.R_OK):
    g_xclbin = args.xclbin
  else:
    sys.exit("ERROR: Specified xclbin file does not exist or is not readable.")

  if os.path.isfile(args.netcfg) and os.access(args.netcfg, os.R_OK):
    g_netFile = args.netcfg
  else:
    sys.exit("ERROR: Specified netcfg file does not exist or is not readable.")

  if os.path.isfile(args.quantizecfg) and os.access(args.quantizecfg, os.R_OK):
    g_fpgaCfgFile = args.quantizecfg
    g_doQuant = True
  else:
    sys.exit("ERROR: Specified quantizecfg file does not exist or is not readable.")

  if os.path.isfile(args.xlnxlib) and os.access(args.xlnxlib, os.R_OK):
    g_xdnnLib = args.xlnxlib
  else:
    sys.exit("ERROR: Specified xlnxlib file does not exist or is not readable.")

  if args.fpgaoutsz:
    g_fpgaOutputSize = int(args.fpgaoutsz)
  if args.outsz:
    g_outputSize = int(args.outsz)
  if args.firstfpgalayer:
    g_firstFpgaLayerName = args.firstfpgalayer

  if os.path.isdir(args.datadir) and os.access(args.datadir, os.R_OK):
    g_xdnnTestDataDir = args.datadir
  else:
    sys.exit("ERROR: Specified datadir directory does not exist or is not readable.")

  if os.path.isfile(args.labels) and os.access(args.labels, os.R_OK):
    g_labelFile = args.labels
  else:
    sys.exit("ERROR: Specified labels file does not exist or is not readable.")

  if os.path.isfile(args.golden) and os.access(args.golden, os.R_OK):
    g_goldenFile = args.golden
  else:
    sys.exit("ERROR: Specified golden file does not exist or is not readable.")

  if os.path.isdir(args.imagedir) and os.access(args.imagedir, os.R_OK):
    g_inputImageDir = args.imagedir
  else:
    sys.exit("ERROR: Specified imagedir directory does not exist or is not readable.")

  if args.useblas:
    g_useBlas = True
  if args.zmqpub:
    g_zmqPub = True
  if args.perpetual:
    g_perpetual = True

def prep_process(q):
  ret = xdnn.createManager(g_xdnnLib)
  if ret != True:
    sys.exit(1)

  cInputBuffer = None
  cFpgaInputBuffer = None
  while True:
    (inputs, inputImageFiles) = prepareImages()
    if inputs is None:
      break

    fpgaInputs = xdnn.quantizeInputs(g_firstFpgaLayerName, 
      inputs, cInputBuffer, cFpgaInputBuffer, g_fpgaCfgFile, g_scaleB)

    q.put((fpgaInputs, inputImageFiles))

  q.put((None, None))

def xdnn_process (qFrom, qTo):
    xdnn_handle = xdnn.createHandle(g_xclbin, "kernelSxdnn_0", g_xdnnLib, g_numDevices)
    if xdnn_handle != 0:
       sys.exit(1)      
    args = { 'datadir': g_xdnnTestDataDir, 
             'quantizecfg': g_fpgaCfgFile, 
             'scaleA': g_scaleA, 
             'scaleB': g_scaleB,
             'PE': -1 }
    weightsBlob = xdnn_io.loadWeightsBiasQuant(args)
    fpgaOutput = prepareOutput(g_batchSize)
    while True:
        (inputs, inputImageFiles) = qFrom.get()
        if inputs is None:
          break

        fpgaInputs = prepareFpgaInputs(inputs)
        if not fpgaInputs:
          break
      
        startTime = timeit.default_timer()        
        xdnn.execute(g_netFile,
          weightsBlob, fpgaInputs, fpgaOutput,
          g_batchSize,  # num batches
          g_fpgaCfgFile, g_scaleB)
        
        qTo.put((fpgaOutput, inputImageFiles))
        
        print "[time] FPGA xdnn execute (%.2f ms):" % ( (timeit.default_timer() - startTime ) * 1000)          
    
    qTo.put ((None, None))
    xdnn.closeHandle()        

class ZmqResultPublisher:
  def __init__(self):
    import zmq
    self.context = zmq.Context()
    self.socket = self.context.socket(zmq.PUB)
    self.socket.bind("tcp://*:5555")

  def send(self, data):
    self.socket.send(data)
        
def main():
  processCommandLine()
  ret = xdnn.createManager(g_xdnnLib)
  if ret != True:
    sys.exit(1)
      
  (fcWeight, fcBias) = xdnn_io.loadFCWeightsBias(g_xdnnTestDataDir)

  # 
  # Spawn the first 2 stages of our pipeline
  # Stage 1: Process JPG
  # Stage 2: Run FPGA "classify"
  qPrep = Queue(maxsize=1)
  qFpga = Queue(maxsize=1)
  prepProc = Process(target=prep_process, args=(qPrep,))  
  xdnnProc = Process(target=xdnn_process, args=(qPrep, qFpga))  
  prepProc.start() 
  xdnnProc.start() 

  #
  # The rest of this function post-processes FPGA output:
  # 1) Compute the final FC + Softmax layers
  # 2) Print classification & accuracy
  # 
  zmqPub = None
  if g_zmqPub:
    zmqPub = ZmqResultPublisher()
  goldenMap = None
  if g_goldenFile:
    goldenMap = getGoldenMap(g_goldenFile, g_labelFile)
  numProcessed = 0
  allTop1 = 0
  allTop5 = 0
  while True:    
    loopTime = timeit.default_timer()
    (fpgaOutput, inputImageFiles) = qFpga.get()

    if type(fpgaOutput) == type(None) \
      and type(inputImageFiles) == type(None):
      break
    
    startTime = timeit.default_timer()
    
    fcOutput = xdnn.computeFC(fcWeight, fcBias, fpgaOutput,
      g_batchSize, g_outputSize, g_fpgaOutputSize, g_useBlas)
    
    elapsedTime = timeit.default_timer() - startTime
    print "[time] FC (%.2f ms)" % (elapsedTime * 1000)
    
    startTime = timeit.default_timer()
    smaxOutput = xdnn.computeSoftmax(fcOutput, g_batchSize)
    elapsedTime = timeit.default_timer() - startTime
    #print "\nAfter Softmax (%.2f ms):" % (elapsedTime * 1000)

    numProcessed += g_batchSize

    (top1, top5) = printClassification(smaxOutput.flatten().tolist(), 
      g_outputSize, inputImageFiles, g_labelFile, goldenMap,
      zmqPub=zmqPub)
    if goldenMap:
      print "Accuracy (i=%d) Top-1: %d, Top-5: %d" \
        % (numProcessed/g_batchSize, top1, top5)
    allTop1 += top1
    allTop5 += top5

    print "Num processed: %d" % numProcessed
    print "\n[time] Total loop (%.2f ms)" % ( (timeit.default_timer() - loopTime ) * 1000)

  if goldenMap and numProcessed: 
    print "\nAverage accuracy (n=%d) Top-1: %.1f%%, Top-5: %.1f%%\n" \
      % (numProcessed, 
         float(allTop1)/float(numProcessed)*100., 
         float(allTop5)/float(numProcessed)*100.)

  prepProc.join()
  xdnnProc.join()

def prepareImages():
  global g_allInputImageFiles
  global g_allInputImageFilesReadIdx
  global g_perpetual
  global g_inputs, g_inputbuf
  if g_allInputImageFiles is None:
    # first time -- collect files from dir
    from os import listdir
    from os.path import isfile, join
    dirents = listdir(g_inputImageDir)
    #dirents = dirents[:4096] # ANDBG
    g_allInputImageFiles = [join(g_inputImageDir, f) \
      for f in dirents if isfile(join(g_inputImageDir, f))]

    numOrigImages = len(g_allInputImageFiles)
    numTestImages = g_batchSize
    if numOrigImages > 0 and numOrigImages < numTestImages:
      # batch size is greater than available images
      # fill up to batch size by reusing existing images
      i = 0
      while len(g_allInputImageFiles) < numTestImages:
        g_allInputImageFiles.append(g_allInputImageFiles[i])
        i = (i+1) % numOrigImages

  startTime = timeit.default_timer()
  if g_allInputImageFilesReadIdx >= len(g_allInputImageFiles):
    return (None, None)

  img_c = 3
  img_h = 224
  img_w = 224
  if g_inputs is None:
    g_inputs = np.zeros((g_batchSize, img_c*img_h*img_w), dtype=np.float32)
    g_inputbuf = np.zeros((g_batchSize, img_c, img_h, img_w), dtype=np.float32)

  inputImageFiles = []
  img_num = 0
  if g_allInputImageFiles:
      # use raw image files from user
    while img_num < g_batchSize \
      and g_allInputImageFilesReadIdx < len(g_allInputImageFiles):
      fname = g_allInputImageFiles[g_allInputImageFilesReadIdx]
      inputImageFiles.append(fname)

      imgStartTime = timeit.default_timer()
      g_inputs[img_num] \
        = xdnn_io.loadImageBlobFromFile(fname, g_mean, img_h, img_w)
      imgElapsedTime = timeit.default_timer() - imgStartTime
      print "[time] loadImageBlobFromFile/OpenCV (%.2f ms)" \
        % (imgElapsedTime * 1000)

      img_num += 1
      g_allInputImageFilesReadIdx += 1
      if g_perpetual:
        g_allInputImageFilesReadIdx \
          = g_allInputImageFilesReadIdx % len(g_allInputImageFiles)
  
  print "[time] prepareImages (%.2f ms):" % ((timeit.default_timer() - startTime) * 1000)

  return (g_inputs, inputImageFiles)

def prepareFpgaInputs(inputs):
  fpgaInputs = xdnn.prepareInputsForFpga(inputs, g_fpgaCfgFile, g_scaleB, -1, g_firstFpgaLayerName)

  return fpgaInputs

def prepareOutput(num):
  (fpgaOutput, fpgaHandle) \
     = xdnn.makeFPGAFloatArray(g_fpgaOutputSize * num)

  return fpgaOutput

def getGoldenMap(goldenFile, labelFile):
  goldenMap = collections.OrderedDict()
  with open(goldenFile, 'r') as f:
    for line in f:
      fname = line[:line.rfind(' ')]
      goldenIdx = int(line[line.rfind(' ')+1:])
      goldenMap[fname] = goldenIdx

  return goldenMap

def checkAccuracy(fname, result, goldenMap):
  # get idx from file name ILSVRC2012_val_00031091.JPEG
  goldenIdx = goldenMap[fname]

  # result is in the form [(value, idx), (value, idx), ...]
  for i,(val,idx) in enumerate(result):
    if i == 0 and idx == goldenIdx:
      return (1, 1)
    elif idx == goldenIdx:
      return (0, 1)

  return (0, 0)

def printClassification(output, outputSize, inputImageFiles, labelFile, goldenMap=None, zmqPub=None):
  labels = []
  with open(labelFile, 'r') as f:
    for line in f:
      labels.append(line.strip())

  idxArr = []
  for i in range(outputSize):
    idxArr.append(i)

  top1count = 0
  top5count = 0

  print "\n"
  zmqMessage = ""
  for i in range(len(inputImageFiles)):
    print "---------- Prediction %d for %s ----------" \
      % (i, inputImageFiles[i])
    if zmqPub:
      zmqMessage += "%s\n" % inputImageFiles[i]
    startIdx = i * outputSize

    vals = output[startIdx:startIdx + outputSize]
    top5 = sorted(zip(vals, idxArr), reverse=True)[:5]

    for j in range(len(top5)):
      confidence = top5[j][0]
      label = labels[top5[j][1]]
      print "%.4f - \"%s\"" % (confidence, label)
      if zmqPub:
        zmqMessage += "%.4f %s\n" % (confidence, label)
    print ""

    if goldenMap != None:
      (t1, t5) = checkAccuracy(os.path.split(inputImageFiles[i])[1], top5, goldenMap)
      top1count += t1
      top5count += t5

  if zmqPub:
    zmqPub.send(zmqMessage)

  return (top1count, top5count)

if __name__ == '__main__':
  main()

